package com.seoulhankuko.app.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.seoulhankuko.app.data.database.entities.UserProgress
import com.seoulhankuko.app.data.repository.LessonRepository
import com.seoulhankuko.app.data.repository.UserProgressRepository
import com.seoulhankuko.app.domain.model.AnswerStatus
import com.seoulhankuko.app.domain.model.ChallengeWithOptions
import com.seoulhankuko.app.domain.model.Constants
import com.seoulhankuko.app.domain.model.LessonWithChallenges
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LessonViewModel @Inject constructor(
    private val lessonRepository: LessonRepository,
    private val userProgressRepository: UserProgressRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(LessonUiState())
    val uiState: StateFlow<LessonUiState> = _uiState.asStateFlow()
    
    fun loadLesson(lessonId: Int) {
        viewModelScope.launch {
            val userId = "default_user" // Temporary implementation
            
            val lessonWithChallenges = lessonRepository.getLessonWithChallenges(lessonId, userId)
            if (lessonWithChallenges != null) {
                userProgressRepository.getUserProgress(userId).collect { userProgress ->
                    val currentChallengeIndex = lessonWithChallenges.challenges.indexOfFirst { !it.completed }
                    
                    _uiState.value = _uiState.value.copy(
                        lessonWithChallenges = lessonWithChallenges,
                        userProgress = userProgress,
                        currentChallengeIndex = if (currentChallengeIndex == -1) 0 else currentChallengeIndex,
                        isLoading = false
                    )
                }
            }
        }
    }
    
    fun selectOption(optionId: Int) {
        val currentState = _uiState.value
        if (currentState.selectedOption != null) return
        
        _uiState.value = currentState.copy(selectedOption = optionId)
    }
    
    fun checkAnswer() {
        val currentState = _uiState.value
        val selectedOption = currentState.selectedOption ?: return
        val currentChallenge = currentState.getCurrentChallenge() ?: return
        
        val correctOption = currentChallenge.options.find { it.correct }
        val isCorrect = correctOption?.id == selectedOption
        
        viewModelScope.launch {
            val userId = "default_user" // Temporary implementation
            
            if (isCorrect) {
                // Complete challenge
                lessonRepository.completeChallenge(userId, currentChallenge.challenge.id)
                
                // Update points
                userProgressRepository.getUserProgress(userId).collect { userProgress ->
                    if (userProgress != null) {
                        userProgressRepository.updatePoints(userId, userProgress.points + Constants.POINTS_PER_CHALLENGE)
                    }
                }
                
                _uiState.value = currentState.copy(
                    status = AnswerStatus.CORRECT,
                    selectedOption = null
                )
            } else {
                // Reduce hearts
                val heartsReduced = userProgressRepository.reduceHearts(userId)
                
                _uiState.value = currentState.copy(
                    status = AnswerStatus.WRONG,
                    selectedOption = null,
                    heartsReduced = heartsReduced
                )
            }
        }
    }
    
    fun nextChallenge() {
        val currentState = _uiState.value
        val nextIndex = currentState.currentChallengeIndex + 1
        
        if (nextIndex >= currentState.lessonWithChallenges?.challenges?.size ?: 0) {
            // Lesson completed
            _uiState.value = currentState.copy(isLessonCompleted = true)
        } else {
            _uiState.value = currentState.copy(
                currentChallengeIndex = nextIndex,
                status = AnswerStatus.NONE,
                selectedOption = null
            )
        }
    }
    
    fun continueFromWrong() {
        _uiState.value = _uiState.value.copy(
            status = AnswerStatus.NONE,
            selectedOption = null
        )
    }
}

data class LessonUiState(
    val lessonWithChallenges: LessonWithChallenges? = null,
    val userProgress: UserProgress? = null,
    val currentChallengeIndex: Int = 0,
    val selectedOption: Int? = null,
    val status: AnswerStatus = AnswerStatus.NONE,
    val isLoading: Boolean = true,
    val isLessonCompleted: Boolean = false,
    val heartsReduced: Boolean = false
) {
    fun getCurrentChallenge(): ChallengeWithOptions? {
        return lessonWithChallenges?.challenges?.getOrNull(currentChallengeIndex)
    }
    
    fun getProgressPercentage(): Int {
        val challenges = lessonWithChallenges?.challenges ?: return 0
        val completedCount = challenges.count { it.completed }
        return (completedCount * 100) / challenges.size
    }
}
